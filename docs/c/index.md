# 如何理解类型声明

> 在c中，在声明变量时的类型，用于指定变量的存储空间大小和数据类型。但是如果声明比较长，可读性就十分差，尤其是入门时学习其他语言的人来说，可能会感到困惑。

> 我们可以这么理解类型声明，在最前方的类型后面的部分可以看作一个表达式，表达式求值后得到前面的类型，如下：

```c
int *a = 10;
int b[10];
int (*c)[10];
```

> 看一下上方的代码， 第一行，后面的表达式是对a解引用，然后得到前面的类型，即int。所以a是一个指向int的指针。
> 第二行，b通过索引语法得到int。所以b是一个int数组。
> 第三行，后面的表达式是对c解引用后再通过索引语法得到int。所以c是一个指向int数组的指针。

> 接下来，用一点更复杂的表达式:

```c
int (*d)(int);
int (* e[10])(int);
```

> 依然按照表达式来理解， d解引用后可以进行函数操作，并最终返回一个int，所以d是一个指向函数的指针，该函数接受一个int参数并返回一个int。
> e可以进行索引操作，得到的值再进行解引用后可以执行函数操作，所以e是一个长度为10的函数指针数组，每一项都是一个指向函数的指针，该函数接受一个int参数并返回一个int。

# 指针

## 数组名与指针

> 在大部分情况下，数组名可以看作是一个指向数组首元素的常量指针，如下代码可以验证：

```c
int a[3] = {1, 2, 3};
int *p = a;
printf("%d\n", p[0]); // 1
printf("%d\n", *a); // 1
```

::: info
但有两个场景却是例外
1. sizeof函数会返回整个数组的大小，而不是指针的大小。
2. 对数组名进行取地址，得到的是数组指针，而不是数组首元素的指针。
:::

> 下面代码可做验证:
```
int a[3] = {1, 2, 3};
int (*p)[3] = &a; // 数组指针
sizeof(a); // 12
```

## 函数指针

> 函数指针的特点在与编译器对其的处理，因为编译器在执行函数时本身就是通过地址来调用函数的，所以函数指针可以有几种完全不同的写法，但它们的结果却相同，如下

```c
#include <stdio.h>
int a(int x) {
    return x + 1;
}
int (*p)(int) = &a;
int (*q)(int) = a;

int main() {
    printf("%d\n", p(5)); // 6
    printf("%d\n", (*p)(10)); // 11
    printf("%d\n", q(15)); // 16
    printf("%d\n", (*q)(20)); // 21
    return 0;
}
```

> 如上可以看出，在对函数指针赋值时，可以使用函数名或取函数地址，它们的结果相同。而且在使用时，可以进行解引用也可以直接进行函数调用
