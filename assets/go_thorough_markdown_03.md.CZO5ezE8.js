import{_ as s,c as a,o as i,a2 as n}from"./chunks/framework.C62L6tH-.js";const u=JSON.parse('{"title":"03_go程序是如何运行的","description":"","frontmatter":{},"headers":[],"relativePath":"go/thorough/markdown/03.md","filePath":"go/thorough/markdown/03.md"}'),e={name:"go/thorough/markdown/03.md"},l=n(`<h1 id="_03-go程序是如何运行的" tabindex="-1">03_go程序是如何运行的 <a class="header-anchor" href="#_03-go程序是如何运行的" aria-label="Permalink to &quot;03_go程序是如何运行的&quot;">​</a></h1><p><strong>go程序是以<code>main</code>函数作为程序入口吗？</strong></p><blockquote><p>不是,go程序入口并不是咱们编写的<code>main</code>函数,在执行<code>main</code>函数之前，还要做很多初始化的工作</p></blockquote><h2 id="_1-runtime入口" tabindex="-1">1. runtime入口 <a class="header-anchor" href="#_1-runtime入口" aria-label="Permalink to &quot;1. runtime入口&quot;">​</a></h2><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-k9J3_" id="tab-dmkEITu" checked="checked"><label for="tab-dmkEITu">GOROOT/src/runtime/__rt0_amd64_windows.s</label></div><div class="blocks"><div class="language-plan9_x86 vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">plan9_x86</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// rt0代表runtime,amd64代表芯片结构为x86-64,windows即为操作系统</span></span>
<span class="line"><span>TEXT _rt0_amd64_windows(SB),NOSPLIT|NOFRAME,$-8</span></span>
<span class="line"><span>    JMP    _rt0_amd64(SB)</span></span></code></pre></div></div></div><blockquote><p>可以看到上面的汇编的汇编代码又跳转到了另一个方法<code>_rt0_amd64</code></p></blockquote><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-_77-A" id="tab-FGTn8qq" checked="checked"><label for="tab-FGTn8qq">GOROOT/src/runtime/asm_amd64.s</label></div><div class="blocks"><div class="language-plan9_x86 vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">plan9_x86</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>TEXT _rt0_amd64(SB),NOSPLIT,$-8</span></span>
<span class="line"><span>    MOVQ    0(SP), DI   // argc</span></span>
<span class="line"><span>    LEAQ    8(SP), SI   // argv</span></span>
<span class="line"><span>    JMP runtime·rt0_go(SB)</span></span></code></pre></div></div></div><blockquote><p>这段汇编代码将我们输入的命令行参数存储到寄存器中,并跳转到了另一个方法<code>runtime·rt0_go</code></p></blockquote><h2 id="_2-启动g0协程" tabindex="-1">2. 启动g0协程 <a class="header-anchor" href="#_2-启动g0协程" aria-label="Permalink to &quot;2. 启动g0协程&quot;">​</a></h2><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-irTf4" id="tab-THHVNuv" checked="checked"><label for="tab-THHVNuv">GOROOT/src/runtime/asm_amd64.s</label></div><div class="blocks"><div class="language-plan9_x86 vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">plan9_x86</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>TEXT runtime·rt0_go(SB),NOSPLIT|NOFRAME|TOPFRAME,$0</span></span>
<span class="line"><span>    // copy arguments forward on an even stack</span></span>
<span class="line"><span>    MOVQ    DI, AX        // argc</span></span>
<span class="line"><span>    MOVQ    SI, BX        // argv</span></span>
<span class="line"><span>    SUBQ    $(5*8), SP        // 3args 2auto</span></span>
<span class="line"><span>    ANDQ    $~15, SP</span></span>
<span class="line"><span>    MOVQ    AX, 24(SP)</span></span>
<span class="line"><span>    MOVQ    BX, 32(SP)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // create istack out of the given (operating system) stack.</span></span>
<span class="line"><span>    // _cgo_init may update stackguard.</span></span>
<span class="line"><span>    MOVQ    $runtime·g0(SB), DI</span></span>
<span class="line"><span>    LEAQ    (-64*1024)(SP), BX</span></span>
<span class="line"><span>    MOVQ    BX, g_stackguard0(DI)</span></span>
<span class="line"><span>    MOVQ    BX, g_stackguard1(DI)</span></span>
<span class="line"><span>    MOVQ    BX, (g_stack+stack_lo)(DI)</span></span>
<span class="line"><span>    MOVQ    SP, (g_stack+stack_hi)(DI)</span></span></code></pre></div></div></div><blockquote><p>上面的汇编语言第一部分将命令行参数转移到栈上,第二部分开启g0协程</p></blockquote><h3 id="g0协程" tabindex="-1">g0协程 <a class="header-anchor" href="#g0协程" aria-label="Permalink to &quot;g0协程&quot;">​</a></h3><div class="info custom-block"><p class="custom-block-title">INFO</p><ol><li>g0协程是所有go程序的第一个协程</li><li>g0协程是为了调度协程而产生的协程</li></ol></div><h2 id="_3-运行时检测" tabindex="-1">3. 运行时检测 <a class="header-anchor" href="#_3-运行时检测" aria-label="Permalink to &quot;3. 运行时检测&quot;">​</a></h2><blockquote><p>在<code>runtime·rt0_go</code>中,有这样一段代码</p></blockquote><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group--X6nc" id="tab-A0gSl_Z" checked="checked"><label for="tab-A0gSl_Z">plan9_x86</label></div><div class="blocks"><div class="language-plan9_x86 vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">plan9_x86</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>CALL    runtime·check(SB)</span></span></code></pre></div></div></div><blockquote><p>调用了<code>runtime·check</code>方法,这是一个go语言方法,<code>runtime.check</code>,可以在<code>GOROOT/src/runtime/runtime1.go</code>中找到</p></blockquote><p>运行时检测的工作</p><div class="info custom-block"><p class="custom-block-title">INFO</p><ul><li>检查各种类型长度</li><li>检查结构体字段偏移量</li><li>检查CAS操作</li><li>检查指针操作</li><li>检查atomic原子操作</li><li>检查栈的大小是否是2的幂次</li></ul></div><h2 id="_4-参数初始化" tabindex="-1">4. 参数初始化 <a class="header-anchor" href="#_4-参数初始化" aria-label="Permalink to &quot;4. 参数初始化&quot;">​</a></h2><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-2dtxR" id="tab-mcBBgFk" checked="checked"><label for="tab-mcBBgFk">GOROOT/src/runtime/asm_amd64.s</label></div><div class="blocks"><div class="language-plan9_x86 vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">plan9_x86</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>CALL    runtime·args(SB)</span></span></code></pre></div></div></div><blockquote><p>看一下被调用的函数</p></blockquote><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-BBy5Z" id="tab-67f8wKP" checked="checked"><label for="tab-67f8wKP">GOROOT/src/runtime/runtime1.go</label></div><div class="blocks"><div class="language-go vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> **byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    argc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    argv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sysargs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c, v)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></div></div><p>上面的代码将命令行参数转移到go语言代码中</p><ol><li>参数数量赋值给<code>argc int32</code></li><li>参数值赋给<code>argv **byte</code></li></ol><h2 id="_5-调度器初始化" tabindex="-1">5. 调度器初始化 <a class="header-anchor" href="#_5-调度器初始化" aria-label="Permalink to &quot;5. 调度器初始化&quot;">​</a></h2><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-muaFs" id="tab-yhjpWZZ" checked="checked"><label for="tab-yhjpWZZ">GOROOT/src/runtime/asm_amd64.s</label></div><div class="blocks"><div class="language-plan9_x86 vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">plan9_x86</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>CALL    runtime·schedinit(SB)</span></span></code></pre></div></div></div><blockquote><p>参数初始化后调用<code>runtime·schedinit</code>进行调度器初始化</p></blockquote><p>调度器初始化的工作</p><div class="info custom-block"><p class="custom-block-title">INFO</p><ul><li>全局栈空间内存分配</li><li>堆内存空间初始化</li><li>初始化当前系统线程</li><li>算法初始化(map,hash)</li><li>加载命令行参数到<code>os.Args</code></li><li>加载操作系统环境变量</li><li>垃圾回收器参数初始化</li><li>设置process数量</li></ul></div><h2 id="_6-创建主协程" tabindex="-1">6. 创建主协程 <a class="header-anchor" href="#_6-创建主协程" aria-label="Permalink to &quot;6. 创建主协程&quot;">​</a></h2><blockquote><p>初始化工作完成后,go语言会创建一个主协程</p></blockquote><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-TFEo2" id="tab-4P02A84" checked="checked"><label for="tab-4P02A84">plan9_x86</label></div><div class="blocks"><div class="language-plan9_x86 vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">plan9_x86</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>    // create a new goroutine to start program</span></span>
<span class="line"><span>    MOVQ    $runtime·mainPC(SB), AX    // entry</span></span>
<span class="line"><span>    PUSHQ   AX</span></span>
<span class="line"><span>    CALL    runtime·newproc(SB)</span></span>
<span class="line"><span>    POPQ    AX</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // start this M</span></span>
<span class="line"><span>    CALL    runtime·mstart(SB)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    CALL    runtime·abort(SB)    // mstart should never return</span></span>
<span class="line"><span>    RET</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>    DATA   runtime·mainPC+0(SB)/8,$runtime·main&lt;ABIInternal&gt;(SB)</span></span></code></pre></div></div></div><blockquote><p>第一行获取到<code>runtime·mainPC</code>函数的地址,根据最后一行可以得出,<code>runtime·mainPC</code>函数即是<code>runtime·main</code>函数 获取到函数地址后,通过<code>runtime·newproc</code>开启一个协程来调用<code>runtime.main</code>函数,然后使用<code>runtime·mstart</code>启动一个<code>M</code>来调度协程</p></blockquote><h2 id="_7-主协程调用主函数" tabindex="-1">7. 主协程调用主函数 <a class="header-anchor" href="#_7-主协程调用主函数" aria-label="Permalink to &quot;7. 主协程调用主函数&quot;">​</a></h2><blockquote><p>进入runtime.main方法,看看它里面做了什么</p></blockquote><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-qgsLW" id="tab-0YyEazw" checked="checked"><label for="tab-0YyEazw">GOROOT/src/runtime/proc.go</label></div><div class="blocks"><div class="language-go vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// The main goroutine.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 执行runtime包的init方法</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    doInit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(runtime_inittasks) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Must be before defer.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 开启垃圾回收器</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    gcenable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Run the initializing tasks. Depending on build mode this</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // list can arrive a few different ways, but it will always</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // contain the init tasks computed by the linker for all the</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // packages in the program (excluding those added at runtime</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // by package plugin). Run through the modules in dependency</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // order (the order they are initialized by the dynamic</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // loader, i.e. they are added to the moduledata linked list).</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 执行用户的init函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">firstmoduledata; m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m.next {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        doInit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(m.inittasks)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 执行main.main函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> main_main </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// make an indirect call, as the linker doesn&#39;t know the address of the main package when laying down the runtime</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></div></div><blockquote><p>查看<code>main_main</code>方法</p></blockquote><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-LL1kO" id="tab-rQ4SPCp" checked="checked"><label for="tab-rQ4SPCp">GOROOT/src/runtime/proc.go</label></div><div class="blocks"><div class="language-go vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//go:linkname main_main main.main</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main_main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div></div></div><blockquote><p>根据<code>go:link</code>注释,main_main函数会链接到<code>main.main</code>函数</p></blockquote><p>总结一下<code>runtime.main</code>函数所做的工作</p><div class="info custom-block"><p class="custom-block-title">INFO</p><ul><li>执行runtime包的init函数</li><li>启动垃圾回收器</li><li>执行用户依赖的init函数</li><li>执行main.main函数</li></ul></div>`,42),p=[l];function t(c,d,o,h,k,r){return i(),a("div",null,p)}const m=s(e,[["render",t]]);export{u as __pageData,m as default};
