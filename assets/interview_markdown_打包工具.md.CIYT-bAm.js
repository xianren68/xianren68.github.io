import{_ as a,c as e,o,a2 as r}from"./chunks/framework.C62L6tH-.js";const k=JSON.parse('{"title":"打包工具","description":"","frontmatter":{},"headers":[],"relativePath":"interview/markdown/打包工具.md","filePath":"interview/markdown/打包工具.md"}'),t={name:"interview/markdown/打包工具.md"},l=r('<h1 id="打包工具" tabindex="-1">打包工具 <a class="header-anchor" href="#打包工具" aria-label="Permalink to &quot;打包工具&quot;">​</a></h1><h2 id="webpack" tabindex="-1">webpack <a class="header-anchor" href="#webpack" aria-label="Permalink to &quot;webpack&quot;">​</a></h2><h3 id="webpack-打包的流程" tabindex="-1">webpack 打包的流程？ <a class="header-anchor" href="#webpack-打包的流程" aria-label="Permalink to &quot;webpack 打包的流程？&quot;">​</a></h3><h4 id="_1-初始化配置" tabindex="-1">1. 初始化配置 <a class="header-anchor" href="#_1-初始化配置" aria-label="Permalink to &quot;1. 初始化配置&quot;">​</a></h4><blockquote><p>webpack读取并解析配置文件（webpack.config.js），初始化编译环境</p></blockquote><h4 id="_2-构建依赖图" tabindex="-1">2. 构建依赖图 <a class="header-anchor" href="#_2-构建依赖图" aria-label="Permalink to &quot;2. 构建依赖图&quot;">​</a></h4><blockquote><p>从入口文件开始，递归地构建依赖关系图，确定每个模块的依赖关系</p></blockquote><h4 id="_3-加载编译模块" tabindex="-1">3. 加载编译模块 <a class="header-anchor" href="#_3-加载编译模块" aria-label="Permalink to &quot;3. 加载编译模块&quot;">​</a></h4><blockquote><p>使用loader处理每个模块，将模块转换为可执行的JavaScript代码，以便它们可以被打包</p></blockquote><h4 id="_4-优化" tabindex="-1">4. 优化 <a class="header-anchor" href="#_4-优化" aria-label="Permalink to &quot;4. 优化&quot;">​</a></h4><blockquote><p>webpack对依赖关系图进行优化，例如合并相似模块、删除未使用的代码(tree-shaking)、压缩代码等</p></blockquote><h4 id="_5-输出" tabindex="-1">5. 输出 <a class="header-anchor" href="#_5-输出" aria-label="Permalink to &quot;5. 输出&quot;">​</a></h4><blockquote><p>根据依赖关系，将优化后的代码合并输出到指定的文件中,生成最终的bundle文件</p></blockquote><h3 id="loader-和-plugin的区别" tabindex="-1">loader 和 plugin的区别 <a class="header-anchor" href="#loader-和-plugin的区别" aria-label="Permalink to &quot;loader 和 plugin的区别&quot;">​</a></h3><h4 id="loader" tabindex="-1">loader <a class="header-anchor" href="#loader" aria-label="Permalink to &quot;loader&quot;">​</a></h4><blockquote><p>loader本质上是一个函数，这个函数接收内容并返回转换后的结果，loader的作用是使webpack有处理和解析非javascript的的力，可以将其看作一个翻译官，对其他类型的文件进行转译的预处理工作。</p><p>loader在module.rules中配置</p><p>loader在文件打包前执行</p></blockquote><h4 id="plugin" tabindex="-1">plugin <a class="header-anchor" href="#plugin" aria-label="Permalink to &quot;plugin&quot;">​</a></h4><blockquote><p>plugin是一个构造函数（类），它用于拓展webpack的功能，例如压缩图片等</p><p>plugin在plugins中配置</p><p>webpack在整个编译的生命周期中提供了许多钩子函数，插件可以在这些钩子函数上执行来完成它们的工作</p></blockquote>',18),i=[l];function c(n,d,h,p,u,b){return o(),e("div",null,i)}const _=a(t,[["render",c]]);export{k as __pageData,_ as default};
