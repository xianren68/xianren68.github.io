import{_ as a,c as e,o,a2 as t}from"./chunks/framework.C62L6tH-.js";const p=JSON.parse('{"title":"网络","description":"","frontmatter":{},"headers":[],"relativePath":"interview/markdown/网络.md","filePath":"interview/markdown/网络.md"}'),i={name:"interview/markdown/网络.md"},r=t(`<h1 id="网络" tabindex="-1">网络 <a class="header-anchor" href="#网络" aria-label="Permalink to &quot;网络&quot;">​</a></h1><h2 id="websocket的心跳机制是什么" tabindex="-1">websocket的心跳机制是什么？ <a class="header-anchor" href="#websocket的心跳机制是什么" aria-label="Permalink to &quot;websocket的心跳机制是什么？&quot;">​</a></h2><blockquote><p>websocket心跳机制（保活机制） 是一种用于保持websocket连接活跃的策略</p><p>在websocket连接中，心跳机制通过定时发送小的，无害的控制消息（通常称做心跳）来确保连接在长时间内保持打开状态，同时检测连接是否仍然有效</p></blockquote><h3 id="心跳机制的目的" tabindex="-1">心跳机制的目的 <a class="header-anchor" href="#心跳机制的目的" aria-label="Permalink to &quot;心跳机制的目的&quot;">​</a></h3><h4 id="_1-保持连接活跃" tabindex="-1">1. 保持连接活跃 <a class="header-anchor" href="#_1-保持连接活跃" aria-label="Permalink to &quot;1. 保持连接活跃&quot;">​</a></h4><blockquote><p>在某些网络环境中，例如企业网络或防火墙，长时间的非活跃连接会被关闭（如负载均衡器或代理服务器)，定时发送心跳可以防止这种情况的发生</p></blockquote><h4 id="_2-检测连接断开" tabindex="-1">2. 检测连接断开 <a class="header-anchor" href="#_2-检测连接断开" aria-label="Permalink to &quot;2. 检测连接断开&quot;">​</a></h4><blockquote><p>心跳机制可以用于检测服务器或客户端连接是否仍然有效，如果一方没有接收心跳包，另一方可以认为连接已经断开，以便执行相应的措施(如断线重连）</p></blockquote><h4 id="_3-维持代理服务器的连接" tabindex="-1">3. 维持代理服务器的连接 <a class="header-anchor" href="#_3-维持代理服务器的连接" aria-label="Permalink to &quot;3. 维持代理服务器的连接&quot;">​</a></h4><blockquote><p>在通过代理服务器进行websocket连接时，代理服务器可能会关闭长时间未活动的连接，心跳消息可以确保连接在代理服务器上的活跃</p></blockquote><h3 id="需要注意的点" tabindex="-1">需要注意的点 <a class="header-anchor" href="#需要注意的点" aria-label="Permalink to &quot;需要注意的点&quot;">​</a></h3><h4 id="_1-心跳间隔" tabindex="-1">1. 心跳间隔 <a class="header-anchor" href="#_1-心跳间隔" aria-label="Permalink to &quot;1. 心跳间隔&quot;">​</a></h4><blockquote><p>心跳消息的发送间隔应该根据需求以及网络环境来决定，如果间隔太短，则会导致不必要的网络流量，而时间太长则会导致无法即使检测到连接的问题</p></blockquote><h4 id="_2-心跳消息的内容" tabindex="-1">2. 心跳消息的内容 <a class="header-anchor" href="#_2-心跳消息的内容" aria-label="Permalink to &quot;2. 心跳消息的内容&quot;">​</a></h4><blockquote><p>心跳消息通常是轻量级的，可以是一个空的websocket帧，或者一个特定格式的心跳消息，重要的是心跳消息不能影响应用程序的正常执行</p></blockquote><h4 id="_3-心跳消息的发送与接收" tabindex="-1">3. 心跳消息的发送与接收 <a class="header-anchor" href="#_3-心跳消息的发送与接收" aria-label="Permalink to &quot;3. 心跳消息的发送与接收&quot;">​</a></h4><blockquote><p>在websocket连接成功后，服务端与客户端都应该定时发送心跳消息，并监听对方的心跳响应</p></blockquote><h4 id="_4-处理未响应的心跳" tabindex="-1">4. 处理未响应的心跳 <a class="header-anchor" href="#_4-处理未响应的心跳" aria-label="Permalink to &quot;4. 处理未响应的心跳&quot;">​</a></h4><blockquote><p>如果一方没有响应心跳，那么就应当认为连接已经断开，并采取相应的措施，例如断线重连或通知用户</p></blockquote><h2 id="跨域" tabindex="-1">跨域 <a class="header-anchor" href="#跨域" aria-label="Permalink to &quot;跨域&quot;">​</a></h2><h3 id="_1-为什么会产生跨域问题" tabindex="-1">1. 为什么会产生跨域问题？ <a class="header-anchor" href="#_1-为什么会产生跨域问题" aria-label="Permalink to &quot;1. 为什么会产生跨域问题？&quot;">​</a></h3><blockquote><p>跨域问题是因为浏览器同源策略(Same-Origin policy) 而产生的，同源策略指请求的域名，端口，以及协议必须与提供资源的网站相同，当一个网页试图访问一个其他来源（不同域名、端口、协议）的数据时，浏览器就会阻止请求的接收或发送，从而引发跨域问题</p></blockquote><h3 id="_2-如何解决跨域问题" tabindex="-1">2. 如何解决跨域问题 <a class="header-anchor" href="#_2-如何解决跨域问题" aria-label="Permalink to &quot;2. 如何解决跨域问题&quot;">​</a></h3><h4 id="_1-cors-cross-origin-resource-sharing" tabindex="-1">1. cors (Cross-Origin Resource Sharing ) <a class="header-anchor" href="#_1-cors-cross-origin-resource-sharing" aria-label="Permalink to &quot;1. cors (Cross-Origin Resource Sharing )&quot;">​</a></h4><blockquote><p>通过在服务端设置特定的http响应头，允许特定的外部域访问资源</p></blockquote><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 允许127.0.0.1访问</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Access-Control-Allow-Origin : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">127.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span></span></code></pre></div><h4 id="_2-jsonp-json-with-padding" tabindex="-1">2. jsonp (JSON with padding) <a class="header-anchor" href="#_2-jsonp-json-with-padding" aria-label="Permalink to &quot;2. jsonp (JSON with padding)&quot;">​</a></h4><blockquote><p>利于<code>script</code>标签可以跨域获取脚本的特性，通过动态的创建标签并设置其<code>src</code>属性来获取数据</p></blockquote><h4 id="_3-代理服务器" tabindex="-1">3. 代理服务器 <a class="header-anchor" href="#_3-代理服务器" aria-label="Permalink to &quot;3. 代理服务器&quot;">​</a></h4><blockquote><p>在服务端设置代理，通过代理服务器将请求转发给目标服务器，从而绕过同源策略的限制</p></blockquote><h4 id="_4-websocket连接" tabindex="-1">4. websocket连接 <a class="header-anchor" href="#_4-websocket连接" aria-label="Permalink to &quot;4. websocket连接&quot;">​</a></h4><blockquote><p>使用websocket协议来获取数据</p></blockquote><h3 id="_3-代理服务器的原理是什么" tabindex="-1">3. 代理服务器的原理是什么？ <a class="header-anchor" href="#_3-代理服务器的原理是什么" aria-label="Permalink to &quot;3. 代理服务器的原理是什么？&quot;">​</a></h3><blockquote><p>浏览器的请求和服务端的响应都通过代理服务器转发，浏览器不用理会目标服务器的跨域问题，只要和代理服务器没有跨域问题即可</p></blockquote>`,34),s=[r];function l(h,c,n,d,b,k){return o(),e("div",null,s)}const q=a(i,[["render",l]]);export{p as __pageData,q as default};
